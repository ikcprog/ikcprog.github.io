---
layout: topic
title: Поиск в ширину (BFS)
permalink: topics/bfs/
---
**Поиск в ширину** (англ. breadth-first search, BFS) - метод обхода и поиска пути в графе.
Когда мы говорим слово "обход" мы подразумеваем, что мы посещаем вершины графа в определенном порядке. Одним из часто используемых методов обхода графа является обход в ширину (BFS). Суть BFS достаточно проста. Обход начинается с посещения определённой вершины (для обхода всего графа часто выбирается произвольная вершина). Затем алгоритм посещает соседей этой вершины. За ними - соседей соседей, и так далее.

Ниже представлена визуализация алгоритма BFS. Серым помечены вершины в очереди на посещение, чёрным - уже посещённые.

<img style="display: block; margin: auto; width: 400px" src="./Animated_BFS.gif" />

## Реализация
Для реализации алгоритма нам потребуется очередь из вершин для посещения. При посещении очередной вершины в очередь добавляются все её соседи, которые ещё не были посещены и ещё не находятся в очереди. Для проверки, была ли вершина уже посещена, используется массив меток. Изначально $$visited[i] = false$$ для всех $$i$$, кроме начальной вершины. При добавлении вершины $$i$$ в очередь $$visited[i]$$ присваивается $$true$$.

{% highlight cpp %}
#include <iostream>
#include <queue>

using namespace std;

bool used[1900];

vector <vector<int>> graph(100);

void bfs(int u)
{
	queue <int> q;
	q.push(u);
	used[u] = true;
	while (!q.empty())
	{
		int current = q.front();
		q.pop();
		cout << current << endl;
		for (auto neighbor : graph[current])
		{
			if (!used[neighbor])
			{
				q.push(neighbor);
				used[neighbor] = true;
			}
		}
	}
}
  {% endhighlight %}
Мы создали функцию bfs с аргументом u - вершиной, с которой мы начинаем обходить граф. Теперь вызовем её в функции main:

{% highlight cpp %}
int main()
{
	cout << "Enter a number of edges: ";
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		int u, v;
		cin >> u >> v;
		
		graph[u].push_back(v);
		graph[v].push_back(u);
	}
	for (int i = 1; i <= n; i++)
	{
		if (!used[i])
			bfs(i);
	}
	return 0;
}
  {% endhighlight %}

Теперь усложним задачу - нам нужно определить расстояние от заданной вершины до всех остальных. Для этого создадим массив distance, и обозначим расстояние от начальной вершины до вершины $$i$$ как $$dst[i]$$.
