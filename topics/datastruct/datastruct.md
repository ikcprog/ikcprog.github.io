---
layout: topic
title: Структуры данных
permalink: topics/datastruct/
---
Структура данных - тип организации данных, позволяющий использовать эффективный доступ к модификации данных. Например, массив с константным размером является простейшей структурой данных. В данной статье мы рассмотрим несколько простейших структур данных: стек, очередь и дек.

## Стек
Стек (stack - стопка), является простейшей струтурой данных. Чтобы описать стек, приведем простой пример: представьте что у вас есть стопка бумаг. Все, что вы можете сделать - это положить туда еще одну или взять последнюю. Про остальные листы мы ничего не знаем (на данный момент). Такой принцип реализации называется LIFO (Last In, First Out), подчёркивающая, что элемент, попавший в стек последним, первым будет из него извлечён. Также можно провести аналогию с лифтом - последний вошедший человек будет первым вышедшим из него.

В стандартной библиотеке С++ определен класс stack. Ниже приведен код, который реализует некоторые методы данного класса. 

{% highlight cpp %}
#include <iostream>
#include <stack>

using namespace std;

int main()
{
int n,temp;
stack<int> s;
cin >> n;
for (int i = 0; i < n; i++)
{
	cin >> temp;
	s.push(temp);
}
if (s.empty())
	cout << "Stack is empty" << endl;
else
{
	cout << "The top element of stack is: " << s.top() << endl;
	s.pop();
	cout << "Now the top element of stack is: " << s.top() << endl;
}
return 0;
}
{% endhighlight %}

## Очередь
Очередь (queue) - это структура данных, которая построена по принципу LILO (last in — last out: последним пришел — последним вышел). В C++ уже есть готовый STL контейнер — queue. В очереди, если вы добавите элемент, который вошел самый первый, то он выйдет тоже самым первым. Получается, если вы добавите 4 элемента, то первый добавленный элемент выйдет первым. Для того, чтобы лучше понять принцип очереди, можно представить себе очередь в магазине. Чтобы вас обслужили, требуется, чтобы обслужили всех человек, которые находятся впереди вас. Важное замечание - в очереди невозможно обратиться к определенному элементу.

{% highlight cpp %}
#include <iostream>
#include <queue>

using namespace std;

int main()
{
	int n, temp;
	queue <int> q;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> temp;
		q.push(temp);
	}
	while (!q.empty())//пока очередь не пуста
	{
		cout << "Current element: " << q.front()<<endl;
		q.pop();
	}
	return 0;
}
{% endhighlight %}
