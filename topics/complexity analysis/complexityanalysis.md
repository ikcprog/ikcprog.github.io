---
layout: topic
title: Сложность алгоритма
permalink: topics/complexity analysis/
---

Решая задачи, вы наверняка не раз замечали, что решение, которое на первый взгляд кажется правильным, получает вердикт "Time limit exceeded". Это означает, что ваша программа превысила максимально допустимое время выполнения. Почему так происходит?

Мы можем характеризовать программу по двум параметрам - затраченному времени и затраченной памяти. Из этих двух параметров складывается *эффективность* нашего кода. В данной статье мы не будем рассматривать затраченную память как ключевой параметр, так как если решение не укладывается в ограничение по памяти, оно скорее всего не уложится и в ограничение по времени.

На практике подсчитать точное время работы программы невозможно. Вместо этого в информатике используют зависимость времени работы от входных данных.
Допустим, мы хотим подсчитать сумму элементов в одномерном массиве. Пусть количество элементов равно **n**.

{% highlight cpp %}
int a[100], sum = 0;
//заполняем массив
for(int i = 0;i<n;i++)
sum += a[i];
cout<< sum <<endl;
{% endhighlight %}

Сколько операций мы выполним, чтобы пройтись по массиву? Верный ответ - **n**. Теперь необходимо ввести понятие "О большое". Чтобы  не связываться со сложными математическими определениями скажем, что О большое - это функция, которая показыкает нам сколько операций потребуется для выполнения алгоритма. В данном примере сложность алгоритма - $$ O(n) $$, линейный рост. Это означает, что если мы увеличим количество входных данных в 2 раза, количество операций также возврастет в 2 раза.

Теперь нам нужно подсчитать сумму элементов двумерного массива, где количество строк и столбцов равно **n**:
{% highlight cpp %}
int a[100][100], sum = 0;
//заполняем массив
for(int i = 0;i<n;i++)
{
 for(int j = 0;j<n;j++)
 sum += a[i][j];
}
cout<< sum <<endl;
{% endhighlight %}

Сколько операций мы выполним, чтобы пройтись по массиву? Для этого нужно количество проходов в первом цикле умножить на количество проходов во втором цикле, то есть $$ O(n×n) $$  или же $$ O(n^2) $$. Это квадратичный рост. Иными словами, при увеличении входных данных в 2 раза количество операций возрастет в 4 раза. Если же у нас количество строк равно m, а количество столбцов n, то сложность будет $$ O(m×n) $$.

Чтобы увеличить эффективность алгоритма, нужно заняться оптимизацией. Одиним  из примеров оптимизации является динамическое программирование, о нем мы поговорим в будущем.

Чаще всего для одной переменной встречаются следующие значения сложности:

- \$$O(1)$$

- \$$O(\sqrt N)$$

- \$$O(N)$$

- \$$O(N \log N)$$

- \$$O(N \sqrt N)$$

- \$$O(N^2)$$

- \$$O(2^N)$$

- \$$O(N!)$$

## Практическое применение
Дано число $$n$$, $$1 \le n \ge 10^9 $$. Далее перечислены n целых положительных чисел. Вывести из этих чисел максимальное произведение.
Пример входных данных:
{% highlight cpp %}
5
20 13 44 55 7
{% endhighlight %}
Пример выходных данных:
{% highlight cpp %}
5
20 13 44 55 7
{% endhighlight %}
