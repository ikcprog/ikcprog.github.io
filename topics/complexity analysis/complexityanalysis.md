---
layout: topic
title: Асимптотический анализ сложности
permalink: topics/complexity analysis/
---

Решая задачи, вы наверняка не раз замечали, что правильное решение получает вердикт "Time limit exceeded". Это означает, что ваша программа превысила максимально допустимое время выполнения. Почему так происходит?

Мы можем характеризовать программу по двум параметрам - затраченному времени и затраченной памяти. Из этого складывается *эффективность* нашего кода. Сейчас память не является ключевым параметром, так как если ваше решение не укладывается в ограничение по памяти, оно скорее всего не уложится и в ограничение по времени.

На практике подсчитать точное время работы невозможно. Вместо этого в информатике используют зависимость времени работы от входных данных.
Допустим, мы хотим подсчитать сумму элементов в одномерном массиве. Пусть количество элементов равно **n**.

{% highlight cpp %}
int a[100], sum = 0;
//заполняем массив
for(int i = 0;i<n;i++)
sum += a[i];
cout<< sum <<endl;
{% endhighlight %}

Сколько операций мы выполним, чтобы пройтись по массиву? Верный ответ - **n**. Теперь необходимо ввести понятие "О большое". Чтобы  не связываться со сложными математическими определениями скажем, что О большое - верхнее ограничение для нашей функции. В данном примере сложность алгоритма - $$ O(n) $$, иначе говоря, линейный рост.

Теперь нам нужно подсчитать сумму элементов двумерного массива, где количество строк и столбцов равно **n**:
{% highlight cpp %}
int a[100][100], sum = 0;
//заполняем массив
for(int i = 0;i<n;i++)
{
for(int j = 0;j<n;j++)
sum += a[i][j];
}
cout<< sum <<endl;
{% endhighlight %}

Сколько операций мы выполним, чтобы пройтись по массиву? Для этого нужно количество проходов в первом цикле умножить на количество проходов во втором цикле, то есть $$ O(n×n) $$  или же $$ O(n^2) $$. Чтобы было нагляднее, представьте двумерный массив как квадрат со стороной **n**. Мы ищем площадь этого квадрата, то есть $$ n^2 $$. Если же у нас количество строк равно m, а количество столбцов n, то сложность будет $$ O(m×n) $$.

Чтобы увеличить эффективность алгоритма, нужно заняться оптимизацией. Одиним  из примеров оптимизации является динамическое программирование, о нем мы поговорим в будущем.

Чаще всего для одной переменной встречаются следующие значения сложности:

$$O(1)$$
$$O(\log N)$$
$$O(\log^2 N)$$
$$O(\sqrt[\leftroot{2} 3] N)$$
$$O(\sqrt N)$$
$$O(N)$$
$$O(N \log N)$$
$$O(N \log^2 N)$$
$$O(N \sqrt N)$$
$$O(N^2)$$
$$O(N^2 \log N)$$
$$O(N^3)$$
$$O(2^N)$$
$$O(N!)$$

