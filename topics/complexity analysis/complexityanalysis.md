---
layout: topic
title: Асимптотический анализ сложности
permalink: topics/complexity analysis/
---

Решая задачи, вы наверняка не раз замечали, что правильное решение получает вердикт "Time limit exceeded". Это означает, что ваша программа превысила максимально допустимое время выполнения. Почему так происходит?

Мы можем характеризовать программу по двум параметрам - затраченному времени и затраченной памяти. Из этого складывается *эффективность* нашего кода. Сейчас память не является ключевым параметром, так как если ваше решение не укладывается в ограничение по памяти, оно скорее всего не уложится и в ограничение по времени.

На практике подсчитать точное время работы невозможно. Вместо этого в информатике используют зависимость времени работы от входных данных.
Допустим, мы хотим подсчитать сумму элементов в одномерном масссиве. Пусть колличество элементов равно **n**.

{% highlight cpp %}
int a[100], sum = 0;
//заполняем массив
for(int i = 0;i<n;i++)
sum+=a[i];
cout<< sum <<endl;
{% endhighlight %}

Сколько операций мы выполним, чтобы пройтись по массиву? Верный ответ - **n**. Теперь необходимо ввести понятие "О большое". Чтобы  не связываться со сложными математическими определениями скажем, что О большое - верхнее ограничение для нашей функции. В данном примере сложность алгоритма - O(n), иначе говоря линейный рост.

Теперь нам нужно подсчитать сумму элементов двумерного массива, где колличество строк и столбцов равно **n**:
{% highlight cpp %}
int a[100][100], sum = 0;
//заполняем массив
for(int i = 0;i<n;i++)
{
for(int j = 0;j<n;j++)
sum+=a[i][j];
}
cout<< sum <<endl;
{% endhighlight %}

Сколько операций мы выполним, чтобы пройтись по массиву? Для этого нужно колличетво проходов в первом цикле умножить на колличетво проходов во втором цикле, то есть $$ О(n×n)$$  или же $$ O(n^2) $$. Чтобы было нагляднее, представьте двумерный массив как квадрат со стороной **n**. Мы ищем площадь этого квадрата, то есть $$ n^2 $$. Если же у нас колличкство строк равно m, а колличество столбцов n, то сложность будет $$ О(m×n) $$.

Чтобы увеличить эффективность алгоритма, нужно заняться оптимизацией. Один из примеров оптимизации - динамическое программирование, о нем мы поговорим в будущем.
